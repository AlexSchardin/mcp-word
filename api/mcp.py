# Vercel API wrapper for Python MCP server
# Auto-generated by Poke MCP deployment workflow
# Spawns the MCP server as a subprocess and communicates via stdin/stdout

import json
import subprocess
import sys
import os
import base64
import tempfile
import threading
from http.server import BaseHTTPRequestHandler

# Configuration from deployment analysis
CONFIG_FILE_PATH = "config.json"
LOADING_PATTERN = "env"
REQUIRED_CREDENTIALS = []


class handler(BaseHTTPRequestHandler):
    def do_OPTIONS(self):
        self.send_response(204)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        self.end_headers()

    def do_POST(self):
        # Read request body
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length).decode('utf-8')

        try:
            json_body = json.loads(body)
        except json.JSONDecodeError as e:
            self.send_response(400)
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({
                'jsonrpc': '2.0',
                'error': {'code': -32700, 'message': f'Parse error: {str(e)}'},
                'id': None
            }).encode())
            return

        # Parse credentials from Authorization header
        auth_header = self.headers.get('Authorization', '')
        credentials = {}

        if auth_header.startswith('Bearer '):
            try:
                decoded = base64.b64decode(auth_header[7:]).decode('utf-8')
                credentials = json.loads(decoded)
            except Exception:
                credentials = {'accessToken': auth_header[7:]}

        # Build environment with credentials
        env = os.environ.copy()

        # Vercel has a read-only filesystem except for /tmp
        # Set common credential directory env vars to use /tmp
        env['GOOGLE_MCP_CREDENTIALS_DIR'] = '/tmp/credentials'
        env['MCP_CREDENTIALS_DIR'] = '/tmp/credentials'
        env['HOME'] = '/tmp'  # Some servers use ~/.config paths
        env['TMPDIR'] = '/tmp'
        env['MCP_DEBUG_LOG'] = '/tmp/mcp_server_debug.log'

        # For servers that support external OAuth provider mode (like google_workspace_mcp),
        # enable it to skip local OAuth callback server startup (can't bind ports on Vercel)
        env['MCP_ENABLE_OAUTH21'] = 'true'
        env['EXTERNAL_OAUTH21_PROVIDER'] = 'true'

        env['MCP_ACCESS_TOKEN'] = credentials.get('accessToken', '')
        env['MCP_REFRESH_TOKEN'] = credentials.get('refreshToken', '')
        env['MCP_CLIENT_ID'] = credentials.get('clientId', os.environ.get('MCP_CLIENT_ID', ''))
        env['MCP_CLIENT_SECRET'] = credentials.get('clientSecret', os.environ.get('MCP_CLIENT_SECRET', ''))
        env['MCP_API_KEY'] = credentials.get('apiKey', os.environ.get('MCP_API_KEY', ''))
        env['MCP_USER_EMAIL'] = credentials.get('userEmail', credentials.get('email', ''))

        # Add credentials using their configured envName
        for cred in REQUIRED_CREDENTIALS:
            env_name = cred.get('envName')
            cred_name = cred.get('name')
            if env_name and cred_name and credentials.get(cred_name):
                env[env_name] = credentials[cred_name]

        # For file-based servers, write credentials to config file
        temp_config_dir = None
        if LOADING_PATTERN == 'file':
            try:
                temp_config_dir = tempfile.mkdtemp(prefix='mcp-config-')
                config_object = {}

                for cred in REQUIRED_CREDENTIALS:
                    config_path = cred.get('configPath') or cred.get('name')
                    cred_name = cred.get('name')
                    if credentials.get(cred_name):
                        config_object[config_path] = credentials[cred_name]
                    elif cred.get('isAppCredential') and cred.get('envName'):
                        config_object[config_path] = os.environ.get(cred['envName'], '')

                # Add common credential names
                if credentials.get('clientId') and 'clientId' not in config_object:
                    config_object['clientId'] = credentials['clientId']
                if credentials.get('clientSecret') and 'clientSecret' not in config_object:
                    config_object['clientSecret'] = credentials['clientSecret']
                if credentials.get('accessToken') and 'accessToken' not in config_object:
                    config_object['accessToken'] = credentials['accessToken']
                if credentials.get('refreshToken') and 'refreshToken' not in config_object:
                    config_object['refreshToken'] = credentials['refreshToken']
                if 'redirectUri' not in config_object:
                    config_object['redirectUri'] = 'http://localhost:8888/callback'

                config_path = os.path.join(temp_config_dir, os.path.basename(CONFIG_FILE_PATH))
                with open(config_path, 'w') as f:
                    json.dump(config_object, f, indent=2)

                # Also write to project root for servers that look there
                project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                try:
                    with open(os.path.join(project_root, os.path.basename(CONFIG_FILE_PATH)), 'w') as f:
                        json.dump(config_object, f, indent=2)
                except Exception:
                    pass

            except Exception as e:
                print(f'[MCP_API] Failed to write config file: {e}', file=sys.stderr)

        # Find and run the Python MCP server
        # Try common entry points
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        possible_entry_points = [
            'main.py',
            'src/main.py',
            'server.py',
            'src/server.py',
            'app.py',
            '__main__.py',
        ]

        entry_point = None
        for ep in possible_entry_points:
            full_path = os.path.join(project_root, ep)
            if os.path.exists(full_path):
                entry_point = full_path
                break

        if not entry_point:
            self.send_response(500)
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({
                'jsonrpc': '2.0',
                'error': {'code': -32000, 'message': 'Could not find Python entry point'},
                'id': json_body.get('id')
            }).encode())
            return

        process = None
        try:
            # Run the MCP server as a subprocess using Popen for bidirectional communication
            # Most MCP servers need --transport stdio or similar to run in stdio mode

            # Use a wrapper script that:
            # 1. Patches file operations for Vercel's read-only filesystem
            # 2. Pre-populates credentials before the server starts
            # 3. Prevents OAuth callback servers from starting (can't bind ports on serverless)
            # 4. Runs the actual MCP server
            wrapper_script = f'''
import sys
import os
import json
import logging
import socket

# Patch socket operations to prevent OAuth callback servers from starting
# Many MCP servers try to start an HTTP server for OAuth callbacks, but we handle OAuth externally
_original_socket_bind = socket.socket.bind
_fake_server_sockets = set()

def _patched_socket_bind(self, address):
    # If trying to bind to common OAuth callback ports (8000, 8080, etc.), fake it
    if isinstance(address, tuple) and len(address) >= 2:
        port = address[1]
        if port in (8000, 8080, 3000, 5000):
            # Pretend we bound successfully but don't actually bind
            _fake_server_sockets.add(id(self))
            return
    return _original_socket_bind(self, address)

socket.socket.bind = _patched_socket_bind

# Also patch socket.listen and socket.accept for fake sockets
_original_socket_listen = socket.socket.listen
def _patched_socket_listen(self, backlog=None):
    if id(self) in _fake_server_sockets:
        return  # No-op for fake sockets
    if backlog is None:
        return _original_socket_listen(self)
    return _original_socket_listen(self, backlog)
socket.socket.listen = _patched_socket_listen

# Patch connect_ex to return success for fake server ports (used by MinimalOAuthServer to check if port is bound)
_original_socket_connect_ex = socket.socket.connect_ex
def _patched_socket_connect_ex(self, address):
    if isinstance(address, tuple) and len(address) >= 2:
        port = address[1]
        if port in (8000, 8080, 3000, 5000):
            return 0  # Return success (port appears to be listening)
    return _original_socket_connect_ex(self, address)
socket.socket.connect_ex = _patched_socket_connect_ex

# Patch logging.FileHandler to redirect writes outside /tmp to /tmp
_original_file_handler_init = logging.FileHandler.__init__
def _patched_file_handler_init(self, filename, mode='a', encoding=None, delay=False, errors=None):
    # Redirect any path outside /tmp to /tmp
    if not filename.startswith('/tmp'):
        basename = os.path.basename(filename)
        filename = f'/tmp/{{basename}}'
    _original_file_handler_init(self, filename, mode, encoding, delay, errors)
logging.FileHandler.__init__ = _patched_file_handler_init

# Patch builtins.open to redirect writes outside /tmp to /tmp
import builtins
_original_open = builtins.open
def _patched_open(file, mode='r', *args, **kwargs):
    # Only redirect write operations outside /tmp
    if isinstance(file, str) and ('w' in mode or 'a' in mode or 'x' in mode):
        if not file.startswith('/tmp') and not file.startswith('/dev'):
            basename = os.path.basename(file)
            file = f'/tmp/{{basename}}'
    return _original_open(file, mode, *args, **kwargs)
builtins.open = _patched_open

# Pre-populate credentials before server starts
# This handles servers that expect credentials in files/stores
def setup_credentials():
    access_token = os.environ.get('MCP_ACCESS_TOKEN', '')
    refresh_token = os.environ.get('MCP_REFRESH_TOKEN', '')
    client_id = os.environ.get('MCP_CLIENT_ID', '') or os.environ.get('GOOGLE_OAUTH_CLIENT_ID', '')
    client_secret = os.environ.get('MCP_CLIENT_SECRET', '') or os.environ.get('GOOGLE_OAUTH_CLIENT_SECRET', '')
    user_email = os.environ.get('MCP_USER_EMAIL', '')

    if not access_token:
        return

    # Create credentials directory
    creds_dir = os.environ.get('GOOGLE_MCP_CREDENTIALS_DIR', '/tmp/credentials')
    os.makedirs(creds_dir, exist_ok=True)

    # Standard credential format that most OAuth-based servers expect
    creds_data = {{
        'token': access_token,
        'refresh_token': refresh_token,
        'token_uri': 'https://oauth2.googleapis.com/token',
        'client_id': client_id,
        'client_secret': client_secret,
        'scopes': None,  # Will be populated by server if needed
    }}

    # Write credentials to multiple locations for maximum compatibility:

    # 1. User-specific credential file (for servers like google_workspace_mcp)
    if user_email:
        user_creds_path = os.path.join(creds_dir, f'{{user_email}}.json')
        with open(user_creds_path, 'w') as f:
            json.dump(creds_data, f)
        # Also set USER_GOOGLE_EMAIL for servers that use it
        os.environ['USER_GOOGLE_EMAIL'] = user_email

    # 2. Default credentials file (for simpler servers)
    default_creds_path = os.path.join(creds_dir, 'credentials.json')
    with open(default_creds_path, 'w') as f:
        json.dump(creds_data, f)

    # 3. token.json format (common in Google API examples)
    token_path = os.path.join(creds_dir, 'token.json')
    with open(token_path, 'w') as f:
        json.dump(creds_data, f)

setup_credentials()

# Now run the actual entry point using runpy to properly set __file__ and __name__
import runpy
sys.argv = ['{entry_point}', '--transport', 'stdio']
runpy.run_path('{entry_point}', run_name='__main__')
'''

            cmd = [sys.executable, '-c', wrapper_script]

            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=env,
                cwd=project_root
            )

            # Send the JSON-RPC request to stdin
            process.stdin.write(json.dumps(json_body) + '\n')
            process.stdin.flush()

            # Read response with timeout
            response_lines = []
            stderr_lines = []
            got_response = threading.Event()

            def read_stdout():
                try:
                    while True:
                        line = process.stdout.readline()
                        if not line:
                            break
                        response_lines.append(line)
                        # Check if we got a complete JSON-RPC response
                        try:
                            parsed = json.loads(line.strip())
                            if isinstance(parsed, dict) and 'jsonrpc' in parsed:
                                got_response.set()
                                break  # Got our response
                        except json.JSONDecodeError:
                            pass
                except Exception:
                    pass

            def read_stderr():
                try:
                    while True:
                        line = process.stderr.readline()
                        if not line:
                            break
                        stderr_lines.append(line)
                except Exception:
                    pass

            stdout_thread = threading.Thread(target=read_stdout)
            stderr_thread = threading.Thread(target=read_stderr)
            stdout_thread.daemon = True
            stderr_thread.daemon = True
            stdout_thread.start()
            stderr_thread.start()

            # Wait for response with timeout
            got_response.wait(timeout=25)
            stdout_thread.join(timeout=1)
            stderr_thread.join(timeout=0.5)

            # Check for valid JSON-RPC response
            for line in reversed(response_lines):
                line = line.strip()
                if not line:
                    continue
                try:
                    parsed = json.loads(line)
                    if isinstance(parsed, dict) and 'jsonrpc' in parsed:
                        self.send_response(200)
                        self.send_header('Access-Control-Allow-Origin', '*')
                        self.send_header('Content-Type', 'application/json')
                        self.end_headers()
                        self.wfile.write(json.dumps(parsed).encode())
                        return
                except json.JSONDecodeError:
                    continue

            # No valid response found
            self.send_response(500)
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            stderr_data = ''.join(stderr_lines)
            error_msg = 'No valid response from server'
            if stderr_data:
                error_msg += f': {stderr_data[:500]}'
            elif response_lines:
                error_msg += f' (got: {response_lines[0][:200] if response_lines else "nothing"})'
            self.wfile.write(json.dumps({
                'jsonrpc': '2.0',
                'error': {'code': -32000, 'message': error_msg},
                'id': json_body.get('id')
            }).encode())

        except Exception as e:
            self.send_response(500)
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({
                'jsonrpc': '2.0',
                'error': {'code': -32000, 'message': f'Failed to run server: {str(e)}'},
                'id': json_body.get('id')
            }).encode())
        finally:
            # Clean up
            if process:
                try:
                    process.terminate()
                    process.wait(timeout=2)
                except Exception:
                    try:
                        process.kill()
                    except Exception:
                        pass
            if temp_config_dir:
                try:
                    import shutil
                    shutil.rmtree(temp_config_dir, ignore_errors=True)
                except Exception:
                    pass
